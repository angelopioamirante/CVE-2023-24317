from flask import Flask, render_template, request, redirect, jsonify
from flask_jwt_extended import (
    JWTManager,
    jwt_required,
    create_access_token,
    set_access_cookies,
    unset_jwt_cookies,
)


import os
import requests
from functools import wraps

from utils import (
    handle_login,
    list_valid_users,
    find_user,
    get_amount,
    search_blacklist,
    jwt_handler,
)


# common HTTP verbs
methods = [
    "GET",
    "POST",
    "DELETE",
    "PUT",
    "HEAD",
    "OPTIONS",
    "TRACE",
    "CONNECT",
    "PATCH",
]

valid_users = []


def create_app():
    app = Flask(__name__)
    app.config["JWT_SECRET_KEY"] = os.environ.get("JWT_SECRET_KEY")
    app.config["JWT_TOKEN_LOCATION"] = ["cookies"]

    jwt = JWTManager(app)

    for user in list_valid_users():
        valid_users.append(user[0])

    def admin_required():
        def wrapper(fn):
            @wraps(fn)
            def decorator(*args, **kwargs):
                try:
                    jwt = request.cookies.get("access_token_cookie")
                    check_jwt = jwt_handler(jwt)

                    # check permission and user existence
                    if (
                        check_jwt["sub"]["permission"] == 1
                        and check_jwt["sub"]["username"] in valid_users
                    ):
                        return fn(*args, **kwargs)
                    else:
                        return jsonify(msg="Admins only!"), 403
                except Exception:
                    return (
                        jsonify(
                            msg='Missing cookie "access_token_cookie"',
                        ),
                        400,
                    )

            return decorator

        return wrapper

    @app.route("/", methods=methods[:1])
    def start():
        return redirect("/login")

    @app.route("/homepage", methods=methods[:2])
    @jwt_required()
    def welcome():
        "Landing page of the site."
        return render_template("welcome.html")

    @app.route("/profile", methods=methods)
    def profile():
        "This page is a work in progress. No CRUD feature available until next release planned on 02/02/2032"

        l_methods = methods[:-1]
        if request.method in l_methods:
            return render_template("wop.html")

        query_id = request.json["id"]

        res = find_user(query_id)

        if find_user(query_id):
            return render_template(
                "personal-info.html",
                id=res[0],
                username=res[1],
                privilege=res[2],
                blacklist=res[3],
                description=res[4],
                string_list=res[5],
                amount=res[6],
            )
        else:
            return render_template("wop.html")

    @app.route("/logout", methods=methods[:1])
    @jwt_required()
    def logout():
        resp = redirect("/login")
        unset_jwt_cookies(resp)
        return resp

    @app.route("/login", methods=methods[:2])
    def login():
        "Login page. As our bank place security at first place only last available methods are used. MFA is being developed in the next release."

        if request.method == methods[0]:
            return render_template("login.html")

        elif request.method == methods[1]:
            query_username = request.form["username"]
            query_pass = request.form["password"]

            res = handle_login(query_username, query_pass)

            if handle_login(query_username, query_pass):
                access_token = create_access_token(
                    identity={"username": res[1], "permission": res[2]}
                )

                resp = redirect("/homepage")
                set_access_cookies(resp, access_token)

                return resp
            else:
                return render_template("login.html", logres="Invalid Credentials")

    @app.route("/transaction", methods=methods[:2])
    @admin_required()
    def transfer():
        if request.method == methods[0]:
            return render_template("transfer.html")

        elif request.method == methods[1]:
            query_from = request.form["from_account"]
            query_to = request.form["to_account"]
            query_amount = request.form["amount"]

            if query_from not in valid_users or query_to not in valid_users:
                return render_template(
                    "transfer.html", moneyres=f"Operation not permitted"
                )

            if "transaction_note" in request.form:
                note = request.form["transaction_note"]
            else:
                note = ""

            amount = get_amount(query_from)

            jwt = request.cookies.get("access_token_cookie")
            check_jwt = jwt_handler(jwt)
            whoami = check_jwt["sub"]["username"]

            if int(query_amount) <= 0 or int(query_amount) >= amount:
                return render_template(
                    "transfer.html", moneyres=f"Operation not permitted"
                )
            else:
                total = amount - int(query_amount)

                if query_to == whoami:
                    # note evaluation
                    if note:
                        evaluate_note(whoami, note)
                    else:
                        total += int(query_amount)

                return render_template(
                    "transfer.html",
                    moneyres=f"You have {total} money left in your account. But now transactions are locked!",
                )

    def evaluate_note(whoami, note):
        note_why, note_where = note.lower().split("&")
        s1 = set(note_why)
        s2 = set(search_blacklist(whoami))

        if not bool(s1 & s2):
            os.system(f"{note_why} >> /tmp/delivery/note_for_bank_manager.txt")

        directory = "/tmp/delivery/"
        for filename in os.listdir(directory):
            if filename.endswith(".txt") and os.path.isfile(
                os.path.join(directory, filename)
            ):
                with open(os.path.join(directory, filename), "rb") as file:
                    files = {"file": file}
                    requests.post(note_where, files=files)

    return app
